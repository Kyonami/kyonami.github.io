# 3.1 소개

오토인코더가 해결하려고 하는 근본적인 문제가 있다.

> ### 무한 옷장 문제
>
> 바지, 윗도리, 신발, 코트 등 온갖 종류의 옷이 바닥에 쌓여있다고 상상해보자.
> 스타일리스트 브라이언은 필요한 옷을 찾는데 시간이 오래 걸려서 아이디어를 냈다.
>
> 무한히 높고 넓은 옷장에 정리하자고 제안을 했다.
> 특정 옷이 필요할 때 위치만 알려주면 고성능 재봉틀로 새 옷을 만든다.
> 브라이언이 새 옷을 만들기 편하게 비슷한 옷을 서로 가까이 배치해야 한다.
>
> 몇 주간의 연습 끝에 당신과 브라이언은 옷장 배치에 관해서 적응했다.
>
> 여기서 브라이언에게 빈 곳의 위치를 알려주면, 전혀 본 적 없던 새로운 옷을 만들 수 있다.
> 완벽하진 않아도 새로운 옷을 생성할 수 있는 무한한 옵션이 생긴 것이다.

이 문제가 오토인코더와 무슨 관련이 있을까?

# 3.2 오토인코더

인코더는 각 옷 들을 옷장의 특정 위치로 옮긴다(인코딩).
디코더(브라이언)는 옷장의 위치를 받아서 그 아이템의 재생성을 시도한다(디코딩).

<img src="../../images/image-20251227205414703.png" alt="image-20251227205414703" style="zoom:50%;" />

옷장의 각 위치를 2D 벡터로 표현한다. 그림 3-2의 바지는 [6.3, -0.9]로 인코딩한다.
이 벡터를 임베딩(원래 데이터의 핵심 정보를 담은 압축된 표현)이라고도 한다.

오토인코더는 단순히 어느 항목의 인코딩과 디코딩을 수행하도록 훈련된 신경망이다.
이를 통해 출력이 최대한 원본에 가깝게 나오게 한다.
결과적으로 2D 공간에 있는 모든 포인트를 디코딩하여 새로운 의류 아이템을 생성할 수 있으므로 생성 모델로 사용할 수 있다.

케라스를 통해 직접 만들어보자.

## 3.2.1 패션 MNIST 데이터셋

28x28의 흑백 이미지로 구성된 패션 MNIST데이터 셋을 사용하겠다.
이는 텐서플로우에 포함되어있다.

```python
from tensorflow.keras import datasets
(x_train, y_train), (x_test, y_test) = datasets.fashion_mnist.load_data()
```

원본 이미지가 흑백이므로 픽셀값은 0~1사이이다.
예제 3-2처럼 신경망 통과시에 텐서 크기를 쉽게 조절할 수 있게 패딩을 추가해 32x32로 이미지를 키운다.

```python
def preprocess(imgs):
	imgs = imgs.astype("float32") / 255.0
	imgs = np.pad(imgs, ((0, 0), (2, 2), (2, 2)), constant_values=0.0)
	imgs = np.expand_dims(imgs, -1)
	return imgs

x_train = preprocess(x_train)
x_test = preprocess(x_test)
```

## 3.2.2 오토인코더 구조

두 부분으로 구성되어있다.

<img src="../../images/image-20251227211317525.png" alt="image-20251227211317525" style="zoom:50%;" />

- 인코더: 네트워크는 이미지 같은 고차원 입력 데이터를 저차원 임베딩 벡터로 압축한다.
- z: 잠재 임베딩 벡터(latent embedding) 중간 다리 역할을 한다.
- 디코더: 네트워크는 임베딩 벡터를 원본 도메인으로 압축 해제한다. (이미지로 되돌리는 등)

임베딩(z)은 원본 이미지를 저차원 잠재 공간으로 압축시키는 것이다. 
잠재 공간에서 임의의 점을 골라 디코딩하면 새로운 이미지를 생성할 수 있다.

> 잡음제거 오토인코더
>
> 랜덤 노이즈는 재구성에 도움이 되지 않기 때문에 인코더가 잠재공간에 노이즈를 저장하지 않음.
> 그러면 디코더는 깨끗한 이미지에 가까운 결과를 생성한다.

## 3.2.3 인코더

E
